<h1> Задание 1 </h1>
<h4> Постановка </h4>
<p>Необходимо заменить листенер извне на собственный. Т.е. предполагается, что невозможно редактировать исходный код внешнего листенера.</p>
<h4> Реализация </h4>
<p>см. ReplaceEventListenerTest </p>
<h4> Описание подхода</h4>
<p> Здесь возможно несколько решений, одному из которых я отдам свое предпочтение - способу из коробки (1). В целом, задача сводится к тому, чтобы реализовать свой листенер (контейнер его зарегистрирует, здесь ничего не нужного делать дополнительного) и исключить ненужный листенер. Получается, переформулирую: нужно исключить ненужный листенер. tip: лучше выносить логику из листенеров, которая может быть в будущем потенциально неактуальна, на уровень сервиса. </p>
<h4> Способ 1</h4>
<p>В мире событий приложения всем управляет ApplicationEventMulticaster - интерфейс, имплементаторы которого могут манипулировать несколькими объектами ApplicationListener и публиковать в них события. 
   
   Получается, чтобы отключить слушателя в приложении - достаточно сказать об этом ApplicationEventMulticaster. У интерфейса есть ряд методов для изменения множества слушателей (добавить/удалить). Стоит быть осторожнее с наследованием слушателей (когда бин наследует бин с слушателями - слушатели перейдут новому бину тоже). К тому же, можно управлять не только слушателями-методами, но и полноценными слушателями (они все хранятся вместе, но для EventListener-ов создается обертка ApplicationListenerMethodAdapter). 
   
   Spring создает ApplicationEventMulticaster после создания BPP.
   ApplicationEventPublisher может использовать ApplicationEventMulticaster в качестве делегата для фактической публикации событий.
   
   Здесь важно уточнить:  https://github.com/spring-projects/spring-framework/issues/26638 был заведен в 2021 году. С версии 5.3 появилась возможность исключить слушателей по их идентификатору (по сути, название метода). До этого просто так исключить EventListener из коробки было нельзя (все остальные методы могли отключать целиком по имени бина). Если версия ниже, то стоит реализовать что-то подобное: https://copyprogramming.com/howto/best-practice-for-dynamically-removing-a-spring-applicationlistener </p>
<h4> Способ 2 </h4>
<p>Можно подменить бин при конфигурациях/инъекциях. В случаях, когда интерфейса нет, можно отнаследоваться от внешнего листенера, переопределить метод-слушатель, объявить Bean в конфигурации с именем внешнего листенера и вернуть свой класс + указать spring.main.allow-bean-definition-overriding=true </p>
<p>Способ достаточно запаристый... В тестах проверяется по NeedToRestEvent. </p>
<p>Ситуация 1: Наследуем только 1 из 2 слушателей (на самом деле, указание @EventListener необязательно). Бин объявляем через Сomponent. </p>
<p>Результат: регистрируются оба бина, у внешнего остаются оба слушателя, для нашего работает переопределенный листенер и внешний, который не переопредили (4) </p>
<p> Ситуация 2: Наследуем только 1 из 2 слушателей. Бин объявляем через Component с именем внешнего слушателя.</p>
<p> Результат: .ConflictingBeanDefinitionException: Annotation-specified bean name 'needToRestEventExternalListener' for bean class [com.daleksandrova.springtasks.task1.listener.NeedToRestEventMyListener] conflicts with existing, non-compatible bean definition of same name and class [com.daleksandrova.springtasks.task1.listener.NeedToRestEventExternalListener]</p>
<p> Уберем аннотацию Component и создадим бин в конфигурации с помощью @Bean (т.е. @Bean
                                                                                       public NeedToRestEventExternalListener needToRestEventExternalListener() {
                                                                                           return new NeedToRestEventMyListener();
                                                                                       }). </p>
<p>Результат: The bean 'needToRestEventExternalListener', defined in com.daleksandrova.springtasks.SpringTasksApplication, could not be registered. A bean with that name has already been defined in file com/daleksandrova/springtasks/task1/listener/NeedToRestEventExternalListener.class] and overriding is disabled.</p>
<p> Докрутим, проставим spring.main.allow-bean-definition-overriding=true</p>
<p>Результат: приложение не упало, BF был перезаписан конфигурационным значением. Работают только наши слушатели (переопределенный и унаследованный внешний) (2). Бин зарегистрирован только переопределенный (наш). </p>
<h4> Способ 3 </h4>
<p> Старый добрый АОП. Можно настроить перехват необходимого метода с помощью AroundAdvice и просто… ничего не делать. Подход работающий, но очень костыльный, так как по факту в контейнере будет присутствовать слушатель, которого мы хотим исключить (к тому же, метод каждый раз будет вызываться). При существовании 1 способа совершенно не вижу смысла от этого. </p>
<h4> А может быть... BPP или BFPP? </h4>
<p> Предположим, что мы хотим отсечь нашего листенера еще до этапа инициации бинов - с помощью BFPP.  Имеем доступ к BeanDefinition. Если заглянем в метаданные, увидим annotatedMethods. Просто удалить оттуда информацию не выйдет - коллекция возвращается не исходная. Но проблема даже не в этом, на самом деле.
</p>
<P>Начать стоит с того, где и как Spring создает слушателей, чтобы понять, от чего можно и нельзя плясать. Здесь речь будет исключительно о методах-слушателях (EventListener).
</P>
<p>Рассмотрим вкратце жизненный цикл (только интересующие нас части):
   
   1. invokeBeanFactoryPostProcessors(beanFactory); -отрабатывают BFPP
   2. registerBeanPostProcessors(beanFactory);  —регистрация BPP
   3. initApplicationEventMulticaster(); —отрабатывает создание мультикастера
   4. registerListeners(); —создаются обычные листенеры (которые не EventListener)
   5. Вызывается конструктор слушателя
   6. Допустим, вызывается BeanPostProcessor (before) для него
   7. Начинается создание EventListener-ов и их добавление в контекст </p>
<p>Вся магия происходит в EventListenerMethodProcessor - это, к слову, хитрый BeanFactoryPostProcessor. Логика от BFPP никак не связана с тем, что нам интересно. Все происходит в afterSingletonsInstantiated - а это уже SmartInitializingSingleton интерфейс. Получается, что контейнер настраивает слушателей с помощью !!!рефлексии!!! только после инициации бина (т.е. даже после BPP1). И на это мы никак не повлияем ни BFPP, ни BPP (потому что это !!!рефлексия!!!).
</p>
<h1> Задание 2 </h1>
<h4> Постановка </h4>
 <p>Необходимо синхронно сохранить файл на диск и в базу данных (сущность с его информацией). После успешного сохранения дополнительно положить файл с метаданными сущности на диск (при любом исключении с файлом метаданных не требуется откатывать информацию в БД и на диске о файле).</p>
<h4> Реализация </h4>
<p>см. FileUploadControllerTest </p>
<h4> Описание подхода</h4>
<ol>
<li> Принимаем запрос с клиента.
</li>
<li> Создаем сущность FileEntity.
</li>
<li> Вызываем persist(), чтобы сохранить новую сущность.
</li>
<li> Слушаем событие PrePersist и сохраняем файл в ОС. При каком-либо исключении транзакция будет откачена.
</li>
<li> Записываем изменения в БД явно с помощью flush().</li>
<li> Обновляем entityManager с помощью refresh().</li>
<li> Слушаем событие PostLoad для создания файла с метаданными сущности. При каком-либо исключении транзакция НЕ будет откачена (это наше требование, но теоретически здесь еще можно откатить транзакцию).
</li>
<li> Возвращаем клиенту идентификатор созданной сущности.</li>
</ol>
<h4> Другой подход </h4>
<p> Даже лучше завязываться на события спринга (before commit+after commit), а не на javax (так как при миграции на SB3 возникают issues javax/jakarta - теперь регистрируются только jakarta, можно потерять javax слушателей и не заметить этого). </p>
